There are eight types of self-admitted technical debts:
1.Architecture: Architecture Debts are caused by violations of modularity or using obsolete technology. In violations of modularity, because shortcuts were taken, multiple modules became inter-dependent, while they should be independent. In using obsolete technology, architecturally-significant technology has become obsolete.
2.Build: Build Debts are caused by over-or under-declared dependencies Under-declared dependencies mean dependencies in upstream libraries are not declared and rely on dependencies in lower-level libraries. Over-declared dependencies mean unneeded dependencies are declared.
3.Code: Poor deployment practice, Complex code, Duplicated code, Low-quality code, Multi-thread correctness, Slow algorithm. Complex code means Code has accidental complexity and requires extra refactoring action to reduce this complexity.Dead code means Code is no longer used and needs to be removed. Duplicated code means Code that occurs more than once instead of as a single reusable function. Low-quality code means Code quality is low, for example, because it is unreadable, inconsistent, or violating coding conventions. Multi-thread correctness means Thread-safe code is not correct and may potentially result in synchronization problems or efficiency problems. Slow algorithm means A non-optimal algorithm is utilized that runs slowly.
4.Defect: Defect Debts are caused by Uncorrected known defects, defects are found by developers but ignored or deferred to be fixed.
5.Design: Non-optimal design decisions are adopted.
6.Documentation: Documentation Debts are caused by Low-quality documentation or Outdated documentation. Low-quality documentation means the documentation has been updated reflecting the changes in the system, but the quality of updated documentation is low. Outdated documentation means a function or class is added, removed, or modified in the system, but the documentation has not been updated to reflect the change.
7.Requirements: Requirements Debts are caused by requirements partially implemented or non-functional requirements. Requirements partially implemented means requirements are implemented, but some are not fully implemented.Non-functional requirements means non-functional requirements (e.g. availability, capacity, concurrency, extensibility), as described by scenarios, are not fully satisfied.
8.Test: Expensive tests, Flaky tests, Lack of tests, Low coverage. Expensive tests means Tests are expensive, resulting in slowing down testing activities. Extra refactoring actions are needed to simplify tests. Flaky tests means Tests fail or pass intermittently for the same configuration. Lack of tests means A function is added, but no tests are added to cover the new function. Low coverage means Only part of the source code is executed during testing.

Self-admitted debts have four common sources : code-comments, issues, pull-requests, commit-messages.

Here are some examples: